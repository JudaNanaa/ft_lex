/* A lexical scanner generated by ft_lex */

/* begin standard C headers. */
#include <endian.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <strings.h>
#include <unistd.h>

/* end standard C headers. *//* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_CHAR_TO_INT(c) ((uint8_t) (c))
#define MIN_CAPACITY 1024


FILE *yyin = NULL, *yyout = NULL;

extern int yylineno;
int yylineno = 1;

char *yytext;
int yyleng;

static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = -1;	/* start state number */

static const unsigned char yy_ec[256] =
    { 0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    1,    0,    0,    2,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0
    } ;


static const unsigned int yy_nxt[4][3] =
    {
        {
            0,    0,    1
        },
        {
            0,    2,    0
        },
        {
            0,    0,    3
        },
        {
            0,    0,    0
        }
    } ;


static const int yy_accept[4] =
    {
        0,    0,    0,    1
    } ;


#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (const char* msg )
{
	fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

typedef struct s_buffer {
	char *str;
	size_t len;
	size_t capacity;
	size_t index;
	uint8_t is_init;
} t_buffer;

static t_buffer buffer;

typedef struct s_state {
	char *yytext;
} t_state;

void init_buffer()
{
	buffer.str = calloc(sizeof(char), MIN_CAPACITY + 1);
	if (buffer.str == NULL)
		yy_fatal_error( "out of dynamic memory in init_buffer()" );
	buffer.capacity = MIN_CAPACITY;
	buffer.len = 0;
	buffer.index = 0;
	buffer.is_init = 1;
}

char *add_buffer(char c) {
	if (buffer.len == buffer.capacity) {
		buffer.str = realloc(buffer.str, buffer.capacity * 2);
		if (buffer.str == NULL)
			yy_fatal_error( "out of dynamic memory in add_buffer()" );
	}
	buffer.str[buffer.len] = c;
	buffer.len++;
	buffer.index++;
	return &buffer.str[buffer.len - 1];
}

void if_no_match(char *last_pos) {

	// printf("not match [%s]\n", buffer.str);
	
	if (last_pos == NULL)
		last_pos = buffer.str;
	fwrite(buffer.str, sizeof(char), last_pos + 1 - buffer.str, yyout);
	memmove(buffer.str, last_pos + 1, (&buffer.str[buffer.len]) - (last_pos + 1));
	bzero(&buffer.str[(&buffer.str[buffer.len]) - (last_pos + 1)], buffer.len - ((&buffer.str[buffer.len]) - (last_pos + 1)));
	buffer.len = (&buffer.str[buffer.len]) - (last_pos + 1);
	buffer.str[buffer.len] = '\0';
	buffer.index = 0;
	// printf("remaining if_no_match = [%s]\n", buffer.str);
}

void if_match(char *last_pos) {
	memmove(buffer.str, last_pos + 1, (&buffer.str[buffer.len]) - (last_pos + 1));
	bzero(&buffer.str[(&buffer.str[buffer.len]) - (last_pos + 1)], buffer.len - ((&buffer.str[buffer.len]) - (last_pos + 1)));
	buffer.len = &buffer.str[buffer.len] - (last_pos + 1);
	buffer.str[buffer.len] = '\0';
	buffer.index = 0;
	// printf("remaining if_match = [%s]\n", buffer.str);
}

char *next_char(void) {
	int c;
	
	if (buffer.str[buffer.index] == '\0')
	{
		c = getc(yyin);
		if (c == EOF)
			return NULL;
		return add_buffer(c);
	}
	char *pos = &buffer.str[buffer.index];
	buffer.index++;
	return pos;
}


int yylex(void) {
	int current_state;
	int last_accepting_state;
	char *last_accepting_cpos;
	int c;
	int yy_act;

	if (!yy_init)
	{
		yy_init = 1;

		if (yy_start == -1)
			yy_start = 0;

		if (!yyin)
			yyin = stdin;

		if (!yyout)
			yyout = stdout;

		if (!buffer.is_init)
			init_buffer();
	}

	current_state = yy_start;
	last_accepting_state = yy_start;
	while (1) {
		
		// c = getc(yyin);
		// if (c == EOF)
		// 	break; // TODO a changer
		// char *pos = add_buffer(c);
		char *pos = next_char();
		if (pos == NULL)
			break;
		c = *pos;
		
		unsigned char yy_c = yy_ec[YY_CHAR_TO_INT(c)];
		
		int next_state = yy_nxt[current_state][yy_c];
		if ( yy_accept[next_state] )
		{
			last_accepting_state = next_state;
			last_accepting_cpos = pos;
		}
		if (next_state == 0)
		{
			if (last_accepting_state == 0) {
				if_no_match(last_accepting_cpos);
			}
			else
			{
				if_match(last_accepting_cpos);
				printf("tu as ecris dad\n"); // TODO a changer
			}
			last_accepting_cpos = 0;
			last_accepting_state = 0;
			current_state = 0;
		}
		current_state = next_state;
	}

	printf("chef\n");
	return 1;
}


int main(void)
{
	yylex();
}