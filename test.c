/* A lexical scanner generated by ft_lex */

/* begin standard C headers. */
#include <endian.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <strings.h>
#include <unistd.h>

/* end standard C headers. *//* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_CHAR_TO_INT(c) ((uint8_t) (c))
#define MIN_CAPACITY 1024


FILE *yyin = NULL, *yyout = NULL;

extern int yylineno;
int yylineno = 1;

char *yytext;
int yyleng;

static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = -1;	/* start state number */

#define ECHO fwrite( yytext, (size_t) yyleng, 1, yyout );

typedef struct accept_elem {
	int state;
	size_t len_match;
} a_elem;

typedef struct accept_stack {
	a_elem *t;
	size_t len;
	size_t capacity;
} a_stack;

static a_stack stack = {0};

#define REJECT reject();

static const unsigned char yy_ec[256] =
    { 0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    1,    0,    0,    2,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0
    } ;


static const unsigned int yy_nxt[4][3] =
    {
        {
            0,    0,    1
        },
        {
            0,    2,    0
        },
        {
            0,    0,    3
        },
        {
            0,    0,    0
        }
    } ;


static const int yy_accept[4] =
    {
        0,    0,    0,    1
    } ;


#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (const char* msg )
{
	fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

typedef struct s_buffer {
	char *str;
	size_t len;
	size_t capacity;
	size_t index;
	uint8_t is_init;
} t_buffer;

static t_buffer buffer;

typedef struct s_state {
	char *yytext;
} t_state;

void init_buffer()
{
	buffer.str = calloc(sizeof(char), MIN_CAPACITY + 1);
	if (buffer.str == NULL)
		yy_fatal_error( "out of dynamic memory in init_buffer()" );
	buffer.capacity = MIN_CAPACITY;
	buffer.len = 0;
	buffer.index = 0;
	buffer.is_init = 1;
}

void init_accepting_stack(void) {
	stack.t = calloc(sizeof(a_elem), MIN_CAPACITY);
	if (buffer.str == NULL)
		yy_fatal_error( "out of dynamic memory in init_accepting_stack()" );
	buffer.capacity = MIN_CAPACITY;
	buffer.len = 0;
}

void increase_accepting_stack_len(void) {
	stack.t = realloc(stack.t, stack.capacity * 2);
	if (stack.t == NULL)
		yy_fatal_error( "out of dynamic memory in increase_accepting_stack_len()" );
	stack.capacity *= 2;
}

void push_accepting_state(int state, int len_match) {
	int index = stack.len;

	stack.t[index].state = state;
	stack.t[index].len_match = len_match;
	stack.len++;
	if (stack.len == stack.capacity)
		increase_accepting_stack_len();
}

void if_accepting_state(int number, int len_match) {
	
	switch (number) {
		
	}
}

a_elem pop_accepting_state(void) {
	a_elem pop;

	int index = stack.len - 1;

	pop.state = stack.t[index].state;
	pop.len_match = stack.t[index].len_match;

	stack.len--;
	return pop;
}

char *add_buffer(char c) {
	if (buffer.len == buffer.capacity) {
		buffer.str = realloc(buffer.str, buffer.capacity * 2);
		if (buffer.str == NULL)
			yy_fatal_error( "out of dynamic memory in add_buffer()" );
		buffer.capacity *= 2;
	}
	buffer.str[buffer.len] = c;
	buffer.len++;
	buffer.index++;
	return &buffer.str[buffer.len - 1];
}

void if_no_match(char *last_pos) {

	// printf("not match [%s]\n", buffer.str);
	
	if (last_pos == NULL)
		last_pos = buffer.str;
	fwrite(buffer.str, sizeof(char), last_pos + 1 - buffer.str, yyout);
	memmove(buffer.str, last_pos + 1, (&buffer.str[buffer.len]) - (last_pos + 1));
	bzero(&buffer.str[(&buffer.str[buffer.len]) - (last_pos + 1)], buffer.len - ((&buffer.str[buffer.len]) - (last_pos + 1)));
	buffer.len = (&buffer.str[buffer.len]) - (last_pos + 1);
	buffer.str[buffer.len] = '\0';
	buffer.index = 0;
	// printf("remaining if_no_match = [%s]\n", buffer.str);
}

void set_yytext(a_elem matching_state) {
	yyleng = matching_state.len_match;
	free(yytext);		
	yytext = malloc(sizeof(char) * (yyleng + 1));
	if (yytext == NULL)
		yy_fatal_error( "out of dynamic memory in set_yytext()" );
	memcpy(yytext, buffer.str, yyleng);
	yytext[yyleng] = '\0';
}



char *next_char(void) {
	int c;
	
	if (buffer.str[buffer.index] == '\0')
	{
		c = getc(yyin);
		if (c == EOF)
			return NULL;
		return add_buffer(c);
	}
	char *pos = &buffer.str[buffer.index];
	buffer.index++;
	return pos;
}



void action_for_state(int action)
{
	switch (action) {
		

		default:
			yy_fatal_error("not normal");
	}
}

void if_match() {
	a_elem matching_state = pop_accepting_state();

	char *after_match = buffer.str + matching_state.len_match + 1;

	set_yytext(matching_state);
	action_for_state(matching_state.state);
	memmove(buffer.str, after_match, (&buffer.str[buffer.len]) - (after_match));
	bzero(&buffer.str[(&buffer.str[buffer.len]) - (after_match)], buffer.len - ((&buffer.str[buffer.len]) - (after_match)));
	buffer.len = &buffer.str[buffer.len] - (after_match);
	buffer.str[buffer.len] = '\0';
	buffer.index = 0;
	stack.len = 0;
	// printf("remaining if_match = [%s]\n", buffer.str);
}

void reject(void)
{
	if (stack.len == 0)
		return;

	if_match();
}



int yylex(void) {
	int current_state;
	int last_accepting_state;
	char *last_accepting_cpos = NULL;
	int c;
	int len_match;
	int yy_act;

	if (!yy_init)
	{
		yy_init = 1;

		if (yy_start == -1)
			yy_start = 0;

		if (!yyin)
			yyin = stdin;

		if (!yyout)
			yyout = stdout;

		if (!buffer.is_init)
			init_buffer();
		init_accepting_stack();
	}

	len_match = 0;
	current_state = yy_start;
	last_accepting_state = yy_start;
	while (1) {
		char *pos = next_char();
		if (pos == NULL)
			break;
		c = *pos;
		len_match++;
		unsigned char yy_c = yy_ec[YY_CHAR_TO_INT(c)];
		
		int next_state = yy_nxt[current_state][yy_c];
		if ( yy_accept[next_state] )
		{
			push_accepting_state(next_state, len_match);
			last_accepting_state = next_state;
			last_accepting_cpos = pos;
		}
		if (next_state == 0)
		{
			if (last_accepting_state == 0) {
				if_no_match(last_accepting_cpos);
			}
			else
			{
				if_match();
				printf("chef tu as ecris [%s]\n", yytext); // TODO a changer
				printf("chef la len est de [%d]\n", yyleng); // TODO a changer
			}
			last_accepting_cpos = 0;
			last_accepting_state = 0;
			current_state = 0;
			len_match = 0;
		}
		current_state = next_state;
	}

	free(buffer.str);
	printf("chef\n");
	return 0;
}


int main(void)
{
	yylex();
}